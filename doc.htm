<!DOCTYPE html>
<html lang="zh"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>Doc</title>
      <link rel="stylesheet" href="./doc_files/common.21fe4933.css">
</head>
<body>
  <article class="post-detail-view toggler-parent fade in">
    <section class="detail-content scrollable thin-scroll">
    <div class="post-detail-content-wrap"> <div class="post-content"><div class="simditor routeLinks"> <div class="simditor-body">  <h1><b>1.使用技术概览</b></h1><h2>1.1 持久层</h2><h4>1.1.1 MySQL&nbsp;</h4><p>现存业务常用的RDBMS。</p><p>本项目库名为market。</p><p>项目初因为和现存数据库并在一起，所以表加前缀mall_ 。数据库拆分后，前缀保留。</p><p>表命名规则参照主站。表名全是英文小写，d_开头为dynamic表(数据更新频繁)，s_开发为static表(表示状态等)，m2m_为多对多关联表。</p><p>列名是英文大写，空格用下划线替代。</p><p>表原则上不建关联和约束以免引起性能损耗，但个人建议在新开业务的时候做一下关联，后期再去掉。</p><p>本人惯用的数据库管理软件是Sequel Pro。</p><p><br></p><p><br></p><p><img alt="Screen Shot 2016-08-29 at 11.08.06 AM.png" src="./doc_files/684" width="800" height="684"><br></p><p><br></p><h3>1.1.2 Memcached</h3><p>Memcached是我站用的K-V缓存。</p><p>有几点需要注意。<br></p><ol><li>新站沿用老的Memcached客户端和部分代码，用的客户端是Whalin(Danga) Memcached，并非Google出的Memcached和Spring整合的客户端，遇到问题不要查歪。</li><li>系统做了Whalin Memcached和Spring Cache API的初步整合，可以做到方法级别的AOP缓存。具体方式下面会谈。</li><li>暂时没有实现类似NERV系统的缓存控制机制，但把代码拷过来稍作修改就能实现。</li><li>除了手动设定的方法级别的缓存外（NERV中称对象缓存），系统还开启了Hibernate的二级缓存 + 查询缓存（NERV中称数据库缓存）。</li></ol><p><br></p><h4>对象缓存添加例子</h4><p><img alt="Screen Shot 2016-08-29 at 11.19.33 AM.png" src="./doc_files/422" width="800" height="421"><br></p><p><br></p><p>@Cacheable Annotation的详细用法请参照 <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/cache.html" target="_blank">Spring官方文档</a>&nbsp;以及 <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html" target="_blank">SpEL</a> 的用法</p><p>cachedNames 指定缓存的名字</p><p>key 指定缓存的key</p><p>这里都可以用SpEL拼接名字，例如此处的Module对象就是有type的，SpEL可以顺利地取到。</p><p><br></p><p>Spring Cache API 本身不支持设定缓存过期时间，但是参考了Google Memcached客户端的做法，我根据cacheNames获取过期时间。</p><p>在最后一个#后输入时间就可以指定过期时间。</p><p>可以接受的过期时间格式为：</p><p><br></p><p>小时 : #??h</p><p>天：#??d</p><p>分钟：#??m</p><p>秒：#??s</p><p><br></p><h4>对象缓存清除（Evict）例子</h4><p><br></p><p><img alt="Screen Shot 2016-08-29 at 1.49.00 PM.png" src="./doc_files/188" width="800" height="187"><br></p><p><br></p><p>需要指定的参数同添加，请注意Annotation的格式。</p><p><br></p><h4>查询缓存启用方法</h4><p><img alt="QQ20160830-25.png" src="./doc_files/118" width="800" height="118"><br></p><p><br></p><p>在Repo的查询方法上打这个Annotation就可以开启查询缓存</p><pre class="hljs css"><code><span style="color:#bbb529;">@<span class="hljs-keyword">QueryHints</span></span>(<span style="color:#d0d0ff;"><span class="hljs-keyword">value</span> </span>= {<span style="color:#bbb529;">@<span class="hljs-keyword">QueryHint</span></span>(<span style="color:#d0d0ff;"><span class="hljs-keyword">name</span> </span>= <span style="color:#6a8759;"><span class="hljs-string">"org.hibernate.cacheable"</span></span><span style="color:#cc7832;">, </span><span style="color:#d0d0ff;">value </span>= <span style="color:#6a8759;"><span class="hljs-string">"true"</span></span>)})<br></code></pre><p>查询缓存同样支持原生SQL查询和JPQL查询</p><p><span style="font-size: 20px;"><br></span></p><h2><span style="font-size: 20px;">1.1.3 Spring Data JPA (Hibernate) + QueryDSL</span></h2><p>Spring Data JPA 利用 Hibernate 实现了 JPA 标准。</p><p>JPA标准里的查询语句叫JPQL，和HQL类似。</p><p>可以通过定义接口的方法名生成增删改查的操作，免去了一般查询写 HQL 的麻烦，并且集成了面向 URL 入口的分页和排序。</p><p>这种做法带来的问题是方法名太多、太杂。</p><p>所以为了补充灵活性和保证复杂查询的逻辑清晰，在此引入QueryDSL。如果不想用封装过的查询，也可以直接写原生SQL和JPQL。</p><p>建议在写之前参照 <a href="http://docs.spring.io/spring-data/jpa/docs/current/reference/html/" target="_blank">Spring Data JPA 和 QueryDSL 的文档</a>以及已有的查询。</p><p>Spring的文档很全，基本涵盖了所有的用法。</p><p><br></p><p><img alt="Screen Shot 2016-08-29 at 2.41.22 PM.png" src="./doc_files/219" width="797" height="218"><br></p><p><br></p><p>关于QueryDSL的复杂查询，以下1.3.1有一例。</p><p><br></p><h2>1.2 业务层</h2><h3>1.2.1 Spring Boot</h3><p>Spring Boot 是 Pivot 对 Spring Framework 和开发 Web App 所必须的组件做的一层封装。</p><p>Spring Boot 不鼓励用 XML 配置 Web App，且提供了一系列基于 Java 类的配置方式。<br></p><p>本 App 因为调试和运行环境需要没有采用它内置的Tomcat。<br></p><p>配置上的问题现在基本已经稳定且解决，遇到新的框架层面的问题请 Google 。</p><p><br></p><h3>1.2.2 ModelMapper , Jackson 和 JsonView</h3><p>这三个轮子都和 Domain Entity 转 DTO 相关。</p><p>本系统中，一个持久化的对象（DO）暴露给前端都要经过 DO -&gt; Mapping -&gt; DTO 的过程，前端持久化到后端要经过 DTO -&gt; Mapping -&gt; DO。</p><p>这么做是为了<span style="font-size: 14px;">防止一些懒加载、序列化、前端定制数据结构的问题</span></p><p>Jackson是序列化/反序列化的工具，JsonView控制DTO暴露给前端视图的field，ModelMapper负责Mapping。</p><p>Spring Boot将Jackson的配置和序列化/反序列化过程自动配置且抽象了，一般情况下无需折腾Jackson的配置。</p><p>对于以上DO MAPPING 和 DTO的过程， 以下结合代码说明。</p><p><br></p><p>DTO的全称是Data Transfer Object，用于暴露给前端。</p><p><img alt="QQ20160830-0.png" src="./doc_files/813" width="400" height="812"><br></p><p>以上是商品的批量更新DTO。</p><p>此处的@Data用了Lombok，省略了Getter/Setter, Equals，Hashcode的生成。</p><p>所有的DTO都必须实现AppDTO接口，这是为了方便Service和Controller进行抽象。</p><p>因为工期紧，目前应用内的JsonView都是DETAIL。以后若有数据传输优化需求，可以用此指定需要给每个URL入口返回的field。</p><p><br></p><p>DO的全称是Domain Object，是Hibernate Entity，用于持久化。</p><p><img alt="QQ20160830-1.png" src="./doc_files/1286" width="478" height="1024"><br></p><p>以上是商品的DO。</p><p>所有的DO都必须实现AppDO接口，方便Service和Controller进行抽象。</p><p>App本身不用XML做Hibernate配置，可以用类似的Annotation解决。</p><p><br></p><p>DO和DTO的转换一直是前后端交互的一个痛点。</p><p>在此用一个Assembler将对象转换的逻辑集中到一处。<br></p><p><br></p><p>Assembler理想的状态下应在Controller内调用，但也可在Service中新建。</p><p>根据业务需求，Assembler可以声明为Service，也可以手动控制生成。</p><p><br></p><p><img alt="QQ20160830-6.png" src="./doc_files/200" width="800" height="199"><br></p><p><br></p><p><img alt="QQ20160830-4.png" src="./doc_files/269" width="798" height="268"><br></p><p><br></p><p>以上是若干应用的例子。</p><p><br></p><p>声明一组DO和DTO的Assembler可以这么做</p><p><img alt="QQ20160830-3.png" src="./doc_files/87" width="797" height="86"><br></p><p><br></p><p>如果在ModelMapper完成了Mapping后有更多的事情需要做，可以进行Override（参见ProductDTOAssembler）</p><p><img alt="QQ20160830-2.png" src="./doc_files/445" width="800" height="444"><br></p><p><br></p><h3>1.2.3 Spring Security</h3><p>比起Apache Shiro等一系列类似的方案，Spring Security 是个相对难驾驭的权限框架。</p><p>但是它提供了很好的AOP支持和扩展性，可以提供有状态和无状态的验证、对接多种方案，即便相对麻烦，本系统也采用了Spring Security。</p><p>权限验证的坑大部分已经踩完，但现在又有独立Cookie的需求了，所以代码还是要改的。</p><p><br></p><p>假如基础配置搞定了，验权还是很容易的。</p><p><img alt="QQ20160830-7.png" src="./doc_files/644" width="800" height="644"></p><p>本系统目前权限方面的需求很简单，只有匿名、用户、管理三级，逻辑如上。</p><p><br></p><p><img alt="QQ20160830-8.png" src="./doc_files/174" width="800" height="173"><br></p><p>对应到API的入口，我们只需进行以上配置就可以验权。</p><p>关于Spring Security AOP验权的更多细节，请参照<a href="http://docs.spring.io/spring-security/site/docs/4.1.3.RELEASE/reference/htmlsingle/#jc-method" target="_blank">文档</a>，可以结合SpEL玩出很多花样。</p><p><br></p><p>假如需要更改验权的规则和设定Cookie之类的方式，请首先参照主站的代码，并对本系统的以下逻辑进行更改：</p><p><img alt="QQ20160830-9.png" src="./doc_files/992" width="800" height="992"><br></p><p><br></p><h3>1.2.4 Java 8 Stream API</h3><p>本系统内有不少的逻辑用了 Java 8 的Stream API。</p><p>Stream API 采用了函数式编程的思想，（对我个人来说）表达代码的意图比指令式更清晰，虽然在现有的Web App里不太有人用到，但是在 Hadoop 和 Apache Spark 里却是核心内容。</p><p>我建议有可能的话，多用Stream API来操作集合。</p><p><br></p><p>以下是一个将集合排序并分组的例子，假如用传统的iterator写显然会更麻烦一些。</p><p><br></p><p><img alt="QQ20160830-10.png" src="./doc_files/338" width="800" height="338"><br></p><p><br></p><p>但Java 由于 Checked Excecption 的缘故，在Lambda表达式内必须显式地Catch Exception，这个设计会让代码变得很蛋疼。</p><p>所以这里引入了专门处理Lambda Exception的工具类，使用方法如下：</p><p><img alt="QQ20160830-11.png" src="./doc_files/233" width="799" height="232"><br></p><p><br></p><p>它同样可以处理Consumer的Exception。</p><p><br></p><h2>1.3 表现层</h2><h3>1.3.1 Spring MVC Rest Controller 和 Spring Data Rest</h3><p>不同于代购站的Struts + URLRewrite的模式，这里对URL入口采用了类sinatra框架的方式。</p><p><br></p><p>以下是参数写在URL里的情况</p><p><img alt="QQ20160830-12.png" src="./doc_files/314" width="800" height="314"><br></p><p><br></p><p>以下是参数用JSON形式写在RequestBody里的情况</p><p><img alt="QQ20160830-13.png" src="./doc_files/296" width="800" height="295"><br></p><p><br></p><p>同时，利用了Spring Data Rest的特性，系统可以对任意Model自动生成URL的翻页、排序、简单的等值过滤查询，查询的入口为/api/{model}/query，在API和Service声明完之后就会有。</p><p>这时候前端只需请求 /api/product/query?productStatus.value=已上架&amp;sort=createdAt,asc&amp;size=20&amp;page=1&nbsp;</p><p>就可以完成一个已上架分页商品的查询，按照创建时间排序，每页20个，第二页（page默认从0开始）。</p><p><br></p><p>在更多的情况下，我们需要定制分页接口。</p><p>只要把Pageable 变量写在方法的形式参数里，并返回一个PageJSON&lt;AppDTO&gt;即可。</p><p>具体方式如下图</p><p><br></p><p><img alt="QQ20160830-14.png" src="./doc_files/723" width="800" height="722"><br></p><p><br></p><p>更确切的实现和用法，请参考<a href="http://docs.spring.io/spring-data/rest/docs/2.5.2.RELEASE/reference/html/#getting-started.configuration" target="_blank">Spring Data Rest的文档</a>。</p><p><br></p><h3>1.3.2 Spring MVC Controller 和 Thymeleaf</h3><p>用Java做后端渲染一直是很蛋疼的事情，这里也很难做到优雅。</p><p>为了解决这些问题，有人造了GWT、Vaadin、PrimeFaces等等等等一系列用Java写前端的轮子，初衷都是好的，然而...</p><p>现在企业级开发的趋势是用Angular做后台管理的界面，还是将DOM处理交给了前端框架。</p><p>但对于一些需要SEO的页面，我们始终很难冒风险去采用前后端分离的解决方案。</p><p>JS生成的DOM百度是爬不到的，Google做得也不成熟，最好还是后端把它画出来。</p><p>基本的做法就是在Controller的URL入口方法里拼完一个Model对象，指定需要绑定的View。</p><p>然后在View（HTML模板）里读取Model，渲染页面由模板引擎（Thymeleaf 2.1）处理。</p><p><img alt="QQ20160830-15.png" src="./doc_files/349" width="800" height="348"></p><p>Thymeleaf本质上是一个非常严格的XML Parser，本项目开启了宽松的HTML匹配模式。</p><p>这里举一个简单的应用例子。</p><p><img alt="QQ20160830-16.png" src="./doc_files/692" width="800" height="692"></p><p>Thymeleaf的设计目的是可以双击打开看模板，方便调试。所以你可以在DOM当中写内容，但th:开头的标签会覆盖掉所有的内容。</p><p>比较复杂的筛选器页面也稳定了，目测不会有太过复杂的逻辑和需求。</p><p>假如遇到问题，用法请参看<a href="http://www.thymeleaf.org/doc/tutorials/2.1/usingthymeleaf.html" target="_blank">Thymeleaf文档</a>。</p><p><br></p><h3>1.4 其他</h3><h4>1.4.1 Joda-Time</h4><p>从 Java 6 时代便开始成为替代Java 翔一样的日期API的事实标准。</p><p><br></p><h4>1.4.2 AssertJ</h4><p><img alt="QQ20160830-17.png" src="./doc_files/136" width="800" height="135"><br></p><p>断言框架，用来校验数据（尤其是订单）合法性。</p><p>如果没有静态导入包的话，需要用Assertions.assertThat召唤。</p><p><br></p><h2>2.抽象、封装和使用说明</h2><p>所有的抽象都面向<span style="font-size: 14px;">之前提到过的</span>基础CRUD操作（增删改查）以及DO、DTO的互转。</p><h3>2.1 Assembler</h3><p>Assembler是实现DO和DTO互转的工具。</p><p>它一共有五个基本的用法，如下图所示。</p><p>其中buildPageDTO是分页API使用的。</p><p><img alt="QQ20160830-26.png" src="./doc_files/587" width="800" height="587"><br></p><p><br></p><p>实现特定Model的Assembler有三种方式。</p><p><br></p><h4>2.1.1 直接new</h4><pre class="hljs cpp"><code>DTOAssembler&lt;PropertyDetail<span style="color:#cc7832;">, </span>PropertyDetailDTO&gt; <span style="color:#9876aa;">assembler </span>= <span style="color:#cc7832;"><span class="hljs-keyword">new</span> </span>DTOAssembler&lt;&gt;(PropertyDetail.<span style="color:#cc7832;"><span class="hljs-keyword">class</span>, </span>PropertyDetailDTO.<span style="color:#cc7832;"><span class="hljs-keyword">class</span></span>)<span style="color:#cc7832;">;</span></code></pre><p>因为类型擦除和泛型的其他限制，假如要直接new一个assembler，只能用这么冗长的一句话。</p><p><br></p><h4>2.1.2 继承Assembler类</h4><p><img alt="471dfb26c3.png" src="./doc_files/65" width="593" height="64"><br></p><p><br></p><p><br></p><p><span style="font-size: 14px;">之前提到过的方式。</span><br></p><p>之后直接new这个Assembler就行。</p><p><br></p><h4>2.1.3 把它声明成@Service并注入</h4><p><img alt="QQ20160830-27.png" src="./doc_files/399" width="799" height="398"><br></p><p>在设计初我想避免这种做法。</p><p>Assembler只做数据的Mapping，不应该涉及到数据库查询。</p><p>但这样在一些场景下就会变得死板，Mapping完的数据并不完整，还得在别的地方查一遍。</p><p>想要查询的话，就必须注入Service。</p><p>注入了Service，那就不能随随便便把它new出来了，否则service是注入不进去的。</p><p>所以把它变成事实上的Service更可以满足这种需要。</p><p><img alt="QQ20160830-28.png" src="./doc_files/269(1)" width="798" height="268"><br></p><h3><br></h3><h3>2.2 Repository (Repo)</h3><h4>2.2.1 CRUDRepo</h4><p>Repo是对应一个Model（DO）而言的。</p><p>也就是说，想要对一个DO做增删改查，必须开一个对应的Repo。</p><p><br></p><p>CRUDRepo默认包含下述方法：</p><p><br></p><p></p><p><code></code></p><p><code>Iterable save(Iterable it) // 批量更新或新建</code></p><p><code>DO save(DO do) // 单个更新<span style="font-size: 14px;">或新建</span><br></code></p><p><code>DO findOne(Long id) // 单个查找</code></p><p><code><br></code></p><p><code><span style="font-size: 14px;">Iterable</span>&lt;DO&gt; findAll(Iterable&lt;Long&gt; ids) // 根据id集合批量查找</code></p><p><code><span style="font-size: 14px;">Iterable</span>&lt;DO&gt; findAll() // 查找所有<br></code></p><p><code><span style="font-size: 14px;">Iterable</span>&lt;DO&gt; findAll(Predicate p , Pageable p) // 根据QueryDSL的查询条件查找并分页排序，返回结果的集合<br><span style="font-size: 14px;"><span style="font-size: 14px;">Iterable</span>&lt;DO&gt; findAll(Pageable p) // 查找所有并分页排序<span style="font-size: 14px;">，返回结果的集合</span></span><br></code></p><p><code><span style="font-size: 14px;"><span style="font-size: 14px;">Iterable</span>&lt;DO&gt; findAll(<span style="font-size: 14px;">Predicate</span> p) // 根据QueryDSL的查询条件查找<br><br></span></code></p><p><code><span style="font-size: 14px;">Page&lt;DO&gt; findAll(Predicate p , Pageable p) // 根据<span style="font-size: 14px;">QueryDSL的查询条件查找并分页排序，返回包含结果集合的分页对象</span></span><br></code></p><p><code><span style="font-size: 14px;">Page&lt;DO&gt; findAll(Pageable p)<span style="font-size: 14px;">// 查找所有并分页排序<span style="font-size: 14px;">，返回包含结果集合的分页对象</span></span><br></span></code></p><p><code><br></code></p><p><code>void delete(Iterable&lt;DO&gt; ids)&nbsp;<span style="font-size: 14px;">// 根据id集合批量删除</span></code></p><p><code>void delete(DO entity)<span style="font-size: 14px;">&nbsp;</span><span style="font-size: 14px;">// 根据DO删除</span><br>void delete(Long id)&nbsp;<span style="font-size: 14px;">// 根据id删除</span></code></p><p><code>void deteteAll() // 删除所有</code></p><p><code><br></code></p><p><code>long count() // 统计数量</code></p><p><code>boolean exists(Long id) // 是否存在主键为id的对象</code></p><p><code><br></code></p><p></p><p></p><p><br></p><p>这些方法全都继承自Spring Data JPA的Repository，并加入了QueryDSL支持。<br></p><p><br></p><h5>2.2.1.1 保存/更新</h5><p>保存和更新统一暴露为save。</p><p><u><b>#重要# 判断一个Entity是该新建还是该更新取决于它有没有ID。</b></u></p><p><u><b><br></b></u></p><p>想用Hibernate的persist等方法必须拿到Hibernate的EntityManager。</p><p>Spring Data JPA的文档有具体的方式，但我还没遇到这样的业务场景。</p><p><br></p><h5>2.2.1.2 删除</h5><p>直接用repo的delete方法就好了。</p><p>但一定要小心级联问题。</p><p><br></p><h5>2.2.1.3 查询</h5><p>默认生成的查询只有findOne和findAll两种。</p><p>但这里接受QueryDSL的查询条件。（见1.3.1）</p><p><br></p><h4>2.2.2 CacheableRepo</h4><p>CacheableRepo给CRUDRepo的默认查询都开启了查询缓存。</p><p><br></p><h4>2.2.3 说明</h4><p>继承CRUDRepo/CacheableRepo并实现一个Repo的例子。</p><p><img alt="QQ20160830-30.png" src="./doc_files/113" width="799" height="112"><br></p><p><br></p><p>首先必须如上图这么声明Repo。</p><p><br></p><p><img alt="QQ20160830-29.png" src="./doc_files/441" width="798" height="440"><br></p><p><br></p><p>本图示例了怎么写一个原生SQL。在JPQL里，我推荐这么绑定参数（看箭头），不然就必须用很怪异的?1 ?2来写SQL的PreparedStatement，这个编号完全意味不明。</p><p><br></p><p>再看下面的Spring Data JPA根据方法名生成的查询。它是根据字母的Case来分割单词、生成查询的。如果觉得它生成的查询是慢查询，可以自己用@Query来写。被打上@Query的方法的名字就可以随意写了。</p><p><br></p><p>方法名在Repo里是个很敏感的东西，假如写错了方法名，App都会起不来。</p><p>这里的_代表集合里的一层，也就是去查找Properties集合中元素的某个属性。</p><p><br></p><p><img alt="QQ20160830-31.png" src="./doc_files/46" width="400" height="46"><br></p><p>假如想要对查询加锁，也可以Annotation的方式。</p><p><br></p><p>假如有更多的业务需求，可以查看Spring Data JPA的文档。</p><h3>2.3 Service</h3><h4>2.3.1&nbsp;TransactionalService<br></h4><p>TransactionalService和Repo以及其DO绑定。</p><p>因为有事务上的要求，所以Service对Repo又做了一层封装，套上了Repo，和代购站的事务配置保持一致。</p><p>于是它就被命名为TransactionalService。</p><p>为了保证事务性，TransactionalService内操作自身的DO用Repo，操作其他的均用DO对应的Service。<br></p><p>原则上，Service不产出DTO，但也不能太死板地硬生生做复杂的遍历多次。</p><p>除了基础的增删改查方法外，TransactionService还包含一个getCurrentUser()方法，可以获得当前登录用户的User对象，如果未登录则为null。</p><p><img alt="QQ20160830-32.png" src="./doc_files/1035" width="792" height="1024"><br></p><p><br></p><p>使用TransactionalService仅需要继承该Service，在泛型中指定对应的Repo和DO。</p><p><img alt="QQ20160830-33.png" src="./doc_files/366" width="600" height="366"><br></p><p><br></p><h4>2.3.2 UserService</h4><p>用户服务并没有什么特别之处，但是独立于其他Service的基础服务，和Spring Security有交互。</p><p>它继承了UserDetailService，其中包含了常用的getCurrentUser()。</p><p>另外常用的方法还有getByName(String name) 根据名字获取用户对象 和isAdmin() 是否是管理员;</p><p><br></p><h3>2.4 Rest API</h3><h4>2.4.1 CRUDRest</h4><p>Spring Data Rest本来就有一套内置的暴露Model的机制，但是直接将Model给用户的做法其实不适合复杂应用。</p><p>PS: 这是一个争论很激烈的话题，见&nbsp;<a href="https://rogeralsing.com/2013/12/01/why-mapping-dtos-to-entities-using-automapper-and-entityframework-is-horrible/" target="_blank">反方</a>&nbsp;和 <a href="http://programmers.stackexchange.com/questions/171457/what-is-the-point-of-using-dto-data-transfer-objects" target="_blank">一些辩论</a></p><p>然而实际的场景下，我没见到过用了Hibernate之后把复杂的Model直接暴露给前端的...</p><p>其实我和框架提供的也就相差一层DO-&gt;mapping-&gt;DTO，所以干脆把它自己实现一次。</p><p>首先提供和 Service+Assembler 相对应的增删改查抽象分页排序API，</p><p>再提供一个基础的筛选查询API（不能查Collection，但可以查对象值），具体的方法是读URL参数，再用QueryDSL做查询拼接。具体实现请参考CRUDRest.java</p><p><br></p><p>这里说一下运用方法</p><p><img alt="Snip20160831_5.png" src="./doc_files/245" width="797" height="244"><br></p><p><br></p><p>首先将新建的API声明为@RestController并指定好入口</p><p>接着指定和它对应的Service、DO 和 DTO</p><p>（此处的ReadonlyCRUDRest继承CRUDRest 见2.4.2）</p><p></p><p>即使不填任何逻辑</p><p>系统也会生成一些基本的API</p><p><img alt="Snip20160831_7.png" src="./doc_files/305" width="798" height="304"><br></p><p><br></p><p>这些API的意义可以参考<a href="http://gitlab.geetaku.com/TD/mall_prototype/blob/master_dev/docs/%E6%8A%BD%E8%B1%A1%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5API.md" target="_blank">萌集市的API文档</a></p><p><br></p><p><br></p><p><br></p><h4>2.4.2 ReadonlyCRUDRest</h4><p>它和CRUDRest的唯一区别就是加上了增删改API的权限验证，只有ROLE_ADMIN用户才能访问。</p><p><br></p><h3>2.5 错误处理</h3><p>系统的错误处理目前还不完善，所有的错误都会被ErrorController捕获到。</p><p>见ErrorController.java。</p><p><br></p><p><img alt="Snip20160831_8.png" src="./doc_files/644(1)" width="800" height="643"><br></p><p><br></p><p><img alt="Snip20160831_9.png" src="./doc_files/551" width="799" height="550"><br></p><p>理论上没有200以外的状态码，403会被重定向到首页，其他的逻辑还没有完善。</p><p>假如是面向 /api/** 的请求导致的系统内部错误或Exception，则会抛出一个error字符串JSON。</p><p><br></p><p><br></p><h3>2.6 其他</h3><h3>2.6.1 StatusType Enum和Status DO的比较和获取</h3><p>系统里有很多的状态，直观地描述这类状态必须开ENUM类，那么比较起来就会很麻烦。</p><p>例如OrderStatus就必须对应一个OrderStatusType，比较起来就得这么写</p><p>if(orderStatus.getValue().equals(OrderStatusType.已发货.val))</p><p>太罗嗦了...</p><p><br></p><p>为了缩短这句话，我做了以下改动。</p><p>首先所有的Type名都取对应Status的大写字母，比如OrderStatus的Type就叫OSType，ProductStatus的Type就叫PSType。</p><p>其次给Type和Status的DO加上标示接口。</p><p><img alt="QQ20160830-34.png" src="./doc_files/559" width="600" height="558"><br></p><p><br></p><p><img alt="QQ20160830-36.png" src="./doc_files/290" width="600" height="290"><br></p><p><br></p><p>在对应的Service里实现一个type()方法通过Type ENUM来获取具体的Status DO</p><p><img alt="QQ20160830-37.png" src="./doc_files/250" width="600" height="249"><br></p><p><br></p><p>效果如下</p><p><br></p><p>获取：</p><p><img alt="QQ20160830-38.png" src="./doc_files/134" width="600" height="134"><br></p><p><br></p><p>比较：</p><p><img alt="QQ20160830-39.png" src="./doc_files/228" width="400" height="228"><br></p><p><br></p><p><br></p><h3>2.6.2 后端渲染页面布局</h3><p><br></p><p>目前暂无标题格式化的需求，假如有需求的话，请参考&nbsp;<a href="https://ultraq.github.io/thymeleaf-layout-dialect/Examples.html#configuring-your-title" target="_blank">thymeleaf-layout-dialect的文档</a>&nbsp;。</p><p></p><p>系统只有一种layout，就是页头-页尾的layout。</p><p>要采用layout的页面，就要将新的html里加上如下代码。</p><p>这里的报错可以无视，报错可以通过合理的配置规避，但我没有做这些配置。</p><p><br></p><p><img alt="Snip20160831_12.png" src="./doc_files/402" width="800" height="401"><br></p><p><br></p><p>再说一下怎么改页头页尾。</p><p>系统后端渲染页面的layout目前由三个文件控制。</p><p><img alt="Snip20160831_11.png" src="./doc_files/82" width="200" height="81"><br></p><p><br></p><p>header_footer.html 里包含了&lt;head&gt;标签和&lt;body&gt;标签中通用的内容，模板引擎会将使用layout页面的对应标签里的内容和它作合并。</p><p><br></p><p>header和footer实际上是包含在&lt;body&gt; 标签中的，所以header_footer.html的&lt;body&gt;是这么写的：</p><pre class="hljs xml"><code><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre><p></p><p>header.html和footer.html的HTML实际上是这么替换进去的,这里的content就是引用布局页面的body内容。</p><p><br></p><h3>2.6.3 后端渲染翻页</h3><p>翻页用了一个开源包：<a href="https://github.com/jpenren/thymeleaf-spring-data-dialect" target="_blank">thymeleaf-spring-data-dialect</a></p><p>它内置的几个Decorator都没法满足我们的业务需求，所以我自己实现了一个。</p><p>要改翻页的逻辑，只需要更改AppFullPaginationDecorator.java即可。</p><p>翻页里最敏感的部分还是生成下一页URL的逻辑，现在的翻页是为/product/**的URL定制的，今后如果由其他需求，需要改一处。</p><p><img alt="Snip20160831_13.png" src="./doc_files/466" width="800" height="465"><br></p><p><br></p><p>其他部分的代码都稳定，也没有太大改的必要。</p><p>翻页的HTML在AppFullPaginationDecorator.properties中，如果前端有改动需求，改这个文件里HTML的即可。</p><p><br></p><h2>3.业务和数据结构</h2><p>阅读本节的时候请参照<a href="http://gitlab.geetaku.com/TD/mall_prototype/tree/master_dev/docs" target="_blank">API文档</a>和PM出的原型。<br></p><p>仅列出不容易理解的/设计复杂的部分。</p><p></p><p>下文的聚合会在以后的业务里持续打散和重新组合（比如商家-运费-优惠）（比如商品-订单-购物车），做的时候注意不要耦合过大，说不定以后会拆成微服务，耦合大粒度就粗，效果不明显...</p><p><br></p><h4>3.1 商品聚合</h4><h4>「商品(Product)-分类(Category)-规格&amp;商品属性(PropertyDetail/PropertyType)-商品图片(ProductImage)」</h4><p>下面将规格/属性Key称为PropertyType , 规格/属性Value称为PropertyDetail。</p><p><br></p><ol><li>一个商品可以有多个分类。</li><li>一个商品在录入时指定的非父分类，系统会自动把它加入父分类。</li><li>由于历史遗留问题，规格和商品属性在表里是同一个东西，在程序里也是共用同一种对象。</li><li>商品规格/属性这个概念包含两种对象，<span style="font-size: 14px;">PropertyType &amp;&nbsp;</span><span style="font-size: 14px;">PropertyDetail</span>，其中从<span style="font-size: 14px;">PropertyDetail可以访问到它对应的</span><span style="font-size: 14px;">PropertyType，PropertyType也是PropertyDetail的一部分</span>。</li><li>分类和商品<span style="font-size: 14px;">PropertyType</span>的多对多关系用来维护需要在筛选器里显示的<span style="font-size: 14px;">PropertyType</span>，筛选器会显示<span style="font-size: 14px;">PropertyType</span>内的所有可以查到结果的<span style="font-size: 14px;">PropertyDetail</span>。</li><li><span style="font-size: 14px;">PropertyDetail</span>会被系统去重，空值会被过滤。</li><li><span style="font-size: 14px;">PropertyDetail</span>和商品的关系决定了和商品关联的规格/属性，<span style="font-size: 14px;">PropertyType</span>和商品的关系决定了该<span style="font-size: 14px;">PropertyType</span>下的<span style="font-size: 14px;">PropertyDetail</span>是否是规格，假如有关联，就是规格而非属性。</li><li>在系统里查出商品，当它还是Hibernate持久化对象的时候，properties是所有的<span style="font-size: 14px;">PropertyDetail</span>，attributeTypes决定是否是规格的<span style="font-size: 14px;">PropertyType</span>。但当Product对象被Map成了ProductDTO之后，它的规格就会和属性分开，名为specs的List里就会放规格的<span style="font-size: 14px;">PropertyDetail</span>，properties则是属性的<span style="font-size: 14px;">PropertyDetail</span>。</li><li>在新建商品时，不同Key的规格之间会被做笛卡尔积以组合出很多的商品。批量新建的规格是用逗号分割的，用的前端对象并非ProductDTO而是ProductBatchUpdateDTO。</li><li>通常概念下的不同规格的同一种商品在系统内是不同的商品，但它们通过一个ROOT_PRODUCT_ID关联。</li><li>搜索的时候仅展示根商品（ROOT_PRODUCT_ID为空的商品）。</li><li>商品的主图总是按ID顺序排列集合的第一个。</li></ol><h4>3.2 订单聚合</h4><h4>「订单(Order)-运费模板(ShipTemplate)-运费策略(ShipPolicy)-商家(Vendor)-订单商品中间对象(OrderProductInfo)」</h4><p>这一组Model在数据结构上没有什么坑爹的地方，还是很清晰的。</p><p>但需要注意订单的状态(OrderStatus)和操作(OrderOperation)是双轨的，和原型文档内保持一致。</p><p>订单的验证方面，前端会发它算过的总价过来，如果不对是没法过验证的，这是一层保险措施。</p><p>订单和商品之间由一个订单商品对象来维护他们之间的关系。把它独立成一个对象是因为，今后会在订单的每个商品后都加备注功能，Hibernate的多对多就不能用了。</p><p>订单生成和预览时和前端交互的对象是OrderPreviewDTO而不是OrderDTO，这里面包含了临时的运费模板解决方案，这里的shipType就是运费模板名。我会根据模板名和用户发来的用户地址信息（和主站一致）匹配合适的运费策略（ShipPolicy）。</p><p>订单的生成现在会按照商家分组，但因为没有多商家，所以实际上每次只会有一个订单，于是程序里很多地方的逻辑都是直接写的orders.get(0)，假如以后有拆单需求，务必改掉所有的get(0).</p><p><br></p><p>当前运费模板和运费策略都是一个临时的方案，据说以后会加续重。</p><p>我在ShipPolicy后预留了MAX_WEIGHT字段，可以用这个来实现某种运费模板的续重。</p><p>根据目前的设计，唯一的运费模板由商家和物流公司名字确定。</p><p><br></p><p><br></p><h4>3.3 优惠聚合</h4><h4>「优惠活动(Promotion)-优惠券(Coupon)」</h4><p>每个优惠券背后都有一个优惠活动在支撑它。</p><p>假如想要造一张优惠券，运营大大需要做以下的事情：</p><p>1.新建一个优惠活动</p><p><img alt="Snip20160901_14.png" src="./doc_files/175" width="798" height="174"><br></p><p>优惠活动的信息是用JSON表示的，方便以后扩展。</p><p>现在暂时没有前端管理界面，需要直接改数据库。</p><p>不过API是有的，详见API文档。</p><p></p><p>2.分发优惠券</p><p><img alt="Snip20160901_15.png" src="./doc_files/253" width="599" height="252"><br></p><p>用户持有的是真正的优惠券，然而优惠券真正敏感的部分只有一个ID和USED（是否已用）。</p><p>因为优惠券和优惠活动关联，优惠相关参数是由优惠活动灵活控制的。</p><p>也就是说运营可以随时改它的优惠金额、可以随时停用.....哪怕券已经发了。</p><p><br></p><p>优惠券分发有三种方式</p><p>1.运营建立n张没有发放的券，用户主动来领</p><p>2.运营主动发给所有用户</p><p>3.运营主动发给特定的一或多用户</p><p><br></p><p><br></p><p></p><h4>3.4 购物车(Cart)</h4><p>购物车有两个值得注意的地方</p><p>1.购物车和订单有耦合，我们有补款流程，补款订单（在逻辑上）是可以加到购物车里和现货商品一起凑单的</p><p>2.用户可以在匿名状态下加商品到购物车，登录完之后再做一下merge</p><p><br></p><p>对于第一种情况，我是将购物车里的商品和订单做了一个关联，表示这是一个补款订单的衍生商品，这里一定要小心处理....这块注释也写得最多。</p><p>另外，删除购物车中补款订单（的衍生商品）所用的API和一般的删除API还不一样，这是权宜之计。</p><p><br></p><p>对于第二种情况，未登录的用户我就将商品加到session里，用户登录完的merge时，会发生存多次的情况，所以我在session里加了个手动的锁。</p><p><img alt="Snip20160901_17.png" src="./doc_files/271" width="797" height="270"><br></p><h2><br></h2><h2>4.配置和运行</h2><p><br></p><h4>环境<br></h4><p>Intellij IDEA 15</p><p>JDK 8&nbsp;</p><p>Tomcat 8</p><p><br></p><h4>下载项目</h4><p><a href="http://Gitlab/TD/mall_prototype.git">http://Gitlab/TD/mall_prototype.git</a><br></p><p><br></p><p><img alt="Screen Shot 2016-08-30 at 1.01.54 PM.png" src="./doc_files/146" width="600" height="146"><br></p><p><br></p><p><img alt="Screen Shot 2016-08-30 at 1.02.00 PM.png" src="./doc_files/189" width="598" height="188"><br></p><p><br></p><h4>配置并运行Maven</h4><p><img alt="Screen Shot 2016-08-30 at 1.04.05 PM.png" src="./doc_files/195" width="799" height="194"><br></p><p><br></p><pre class="hljs nginx"><code><span class="hljs-attribute">clean</span> install spring-boot:run -D<span class="hljs-literal">debug</span></code></pre><p><br></p><h4>安装Lombok插件</h4><p><img alt="QQ20160830-18.png" src="./doc_files/628" width="600" height="627"><br></p><p><br></p><p><img alt="QQ20160830-19.png" src="./doc_files/671" width="800" height="671"><br></p><p><br></p><h3>配置Tomcat</h3><h3><img alt="QQ20160830-20.png" src="./doc_files/507" width="799" height="506"></h3><p>默认启动是用的内嵌服务器，但maven启动是打不上断点的。<br></p><p>Spring Boot本身的方式启动热加载不便利，所以用外置的Tomcat。</p><h4>启动</h4><p>启动方式切到Tomcat，点Debug</p><p><img alt="QQ20160830-21.png" src="./doc_files/44" width="200" height="43"></p><p>输入<a href="http://localhost:9999/">http://localhost:9999/</a>查看效果</p><h4>绑定域名</h4><p>将本机和dummy domain绑定以解决前端报的跨域问题</p><p><br></p><h4>API测试工具 Swagger(Spring Fox)</h4><p>本系统采用了Swagger，可以方便地发起API请求，也可以填一些简单的注释。</p><p>Spring Fox是Swagger和Spring适配的封装。它会自动扫描API入口并生成Swagger文档。</p><p><img alt="QQ20160830-22.png" src="./doc_files/359" width="799" height="358"><br></p><p>以上就是写注释的例子。</p><p>更多的配置信息可以参照<a href="https://springfox.github.io/springfox/docs/current/" target="_blank">Spring Fox文档</a>。</p><p><br></p><p>程序跑起来之后，只要访问/swagger-ui.html便可看到如下界面</p><p><br></p><p><img alt="QQ20160830-23.png" src="./doc_files/1200" width="683" height="1024"><br></p><p>输入完参数，点击Try It Out</p><p>便可以得到API的返回结果</p><p><img alt="Screen Shot 2016-08-30 at 1.27.04 PM.png" src="./doc_files/977" width="800" height="976"><br></p>  </div></div></div>  </div>  </section>
</body>
